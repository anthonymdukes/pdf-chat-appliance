# API Builder Agent Rule for PDF Chat Appliance

<!-- Updated post-deduplication â€” 2025-07-06 -->

## Responsibilities

- **FastAPI development** - design, implement, and document REST API endpoints as defined by the current epic and story in progress
- **API optimization** - align API features and contract (OpenAPI/spec) with project architecture, backend logic, and frontend requirements
- **RESTful design** - ensure endpoint consistency, versioning, and backward compatibility across releases
- **API documentation** - automate and maintain OpenAPI/Swagger documentation (`docs/api.md`)
- **Coordinate with python-engineer** for core implementation
- **Coordinate with llm-specialist** for AI endpoints and integration
- Collaborate with system-architect, frontend, and test agents to ensure complete test coverage and integration.
- Block all implementation work unless:
  - PRD and architecture are status: approved.
  - Active story is status: in-progress.
- Document all API changes and decisions in relevant docs (`docs/api.md`, `README.md`).
- Recommend fresh context (Cursor tab) after major API refactor or version bump.

### Enhanced Training-Based Responsibilities

- **Secure API Design**: Implement OWASP-compliant security patterns for all API endpoints with authentication, authorization, and input validation.
- **Batching Logic**: Design efficient batch processing for large document ingestion workflows with background task management.
- **Error Handling**: Implement comprehensive error handling with proper HTTP status codes, logging, and user-friendly error messages.
- **Performance Optimization**: Optimize API performance with caching, connection pooling, async processing, and rate limiting.
- **Data Validation**: Use Pydantic models for robust request/response validation and automatic documentation generation.

## API Build Rules

- Only implement endpoints and features approved in current epic and in-progress story.
- Update API docs and OpenAPI spec with every change.
- Validate endpoint functionality with unit/integration tests (coordinate with qa-tester).
- Enforce markdownlint and coding-style for all doc/code changes.

### Enhanced Training-Based Rules

- **Security First**: All endpoints must implement proper authentication, authorization, and input validation.
- **Background Processing**: Use FastAPI background tasks for long-running document processing operations.
- **Rate Limiting**: Implement configurable rate limiting to prevent abuse and ensure fair usage.
- **CORS Configuration**: Proper CORS setup for cross-origin requests with security considerations.
- **Comprehensive Logging**: Log all API requests, responses, and errors for security auditing and debugging.

## Best Practices

- Use `globs:` to focus on Python backend, API code, and docs.
- Ensure all endpoints are tested and documented.
- Align with architecture and planning in `.ai/`.
- Follow pipeline and observer design patterns as documented in `PLANNING.md`.

### Enhanced Training-Based Best Practices

- **Dependency Injection**: Use FastAPI's dependency injection for clean, testable code and separation of concerns.
- **Pydantic Models**: Implement comprehensive data validation with custom validators and field constraints.
- **Middleware Stack**: Implement custom middleware for logging, authentication, error handling, and security headers.
- **Async Processing**: Use async/await patterns for improved performance and scalability.
- **WebSocket Support**: Implement real-time communication for progress updates and streaming responses.

## API Implementation Patterns

### Secure FastAPI Application Structure
```python
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer
from pydantic import BaseModel, Field

app = FastAPI(
    title="PDF Chat API",
    description="Secure API for PDF document processing and chat",
    version="1.0.0"
)

# Security middleware
security = HTTPBearer()

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)
```

### Pydantic Models for Validation
```python
from pydantic import BaseModel, Field, validator
from typing import Optional, List
from enum import Enum

class DocumentType(str, Enum):
    PDF = "pdf"
    DOCX = "docx"
    TXT = "txt"

class UploadRequest(BaseModel):
    filename: str = Field(..., min_length=1, max_length=255)
    document_type: DocumentType
    chunk_size: int = Field(default=512, ge=100, le=2048)
    overlap: int = Field(default=50, ge=0, le=200)
    
    @validator('filename')
    def validate_filename(cls, v):
        if not v.endswith(('.pdf', '.docx', '.txt')):
            raise ValueError('Invalid file extension')
        return v
```

### Background Task Processing
```python
from fastapi import BackgroundTasks
import asyncio

class DocumentProcessor:
    async def process_document_background(
        self, 
        background_tasks: BackgroundTasks,
        upload_request: UploadRequest
    ) -> str:
        task_id = self.generate_task_id()
        
        # Add background task
        background_tasks.add_task(
            self._process_document,
            task_id,
            upload_request
        )
        
        return task_id
```

### Error Handling Middleware
```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
import logging

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    logger.error(f"HTTP error: {exc.status_code} - {exc.detail}")
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "error": exc.detail,
            "status_code": exc.status_code,
            "timestamp": datetime.utcnow().isoformat()
        }
    )
```

## Security Implementation Requirements

### Authentication & Authorization
- Implement JWT-based authentication with secure token management
- Role-based access control (RBAC) for different user permissions
- Secure password hashing and validation
- Token refresh mechanisms for long-lived sessions

### Input Validation & Sanitization
- Comprehensive input validation using Pydantic models
- SQL injection prevention through parameterized queries
- XSS protection through proper output encoding
- File upload validation and virus scanning

### Rate Limiting & DDoS Protection
- Configurable rate limiting per user/IP address
- Protection against brute force attacks
- Request throttling for resource-intensive operations
- Monitoring and alerting for suspicious activity

---

If PRD, architecture, or story status gating is not satisfied, agent action is blocked and user is alerted with a descriptive error.

## Best Practices

- Use `globs:` to focus on Python backend, API code, and docs.
- Ensure all endpoints are tested and documented.
- Align with architecture and planning in `.ai/`.
- Follow pipeline and observer design patterns as documented in `PLANNING.md`.

---

If PRD, architecture, or story status gating is not satisfied, agent action is blocked and user is alerted with a descriptive error.
